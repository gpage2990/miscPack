% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HDCurves.R
\name{informed_mixture}
\alias{informed_mixture}
\title{Function that fits Gaussian finite mixture model with a variety of induced prior specifications on the number of data clusters.  These models specify a large number of components K}
\usage{
informed_mixture(y,
                 K=25,
                 alpha_prior_type="centered",
                 alpha_prior_dist="pc",
                 mu_sigma_prior=1,
                 basemodel=0,
                 U=4,
                 alpha1_val = 1.0,
                 alpha2_val = 1e-5,
                 update_alpha1=TRUE,
                 update_alpha2=FALSE,
                 hierarchy="NO",
                 m0=0, s20=1, A=10, A0=10,
                 a0=1, b0=1,
                 k0=0.01, nu0 = 4,
                 a_gam=1,  b_gam=1,
                 a1_gam=1, b1_gam=1,
                 a2_gam=1, b2_gam=1,
                 tail.prob=0.01,
                 alpha_grid=NULL, alpha_density=NULL,
                 alpha0=1e-5, alphaMax=1,
                 ndens_y=0,
                 niter=11000,nburn=1000,nthin=10)
}


\description{
\code{informed_mixture} is the main function used to fit Gaussian finite mixture model.

}

\arguments{
\item{y}{numeric vector containing response variable}
\item{K}{number of components in the finite mixture}

\item{alpha_prior_type}{prior specification on alpha with the following two options:}
\itemize{
  \item {sparse - symmetric dirichlet with sparse prior on alpha1}
	\item {centered - asymmetric dirichlet}
}
\item{alpha_prior_dist}{The distribution}
\itemize{
  \item {gamma - gamma distribution for alpha1}
	\item {pc - penalized complexity prior for alpha1}
}
\item{mu_sigma_prior}{The prior distribution used for atoms (muk, sigma2k)}
\itemize{
  \item {1 - muk ~ N(m0, s20), sigmak ~ UN(0,A)}
	\item {2 - muk ~ N(m0, s20), sigma2k ~ IG(a0, b0)}
	\item {3 - (muk, sigma2k) ~ NIG(m0, k0, nu0, s20)}
}
\item{basemodel}{If 0, then basemodel for sparse prior is one componentInidicator determining which base model to use.  This is obslete}
\item{U}{The mode number of data clusters a priori}
\item{alpha1_val}{starting value for alpha1 if alpha1 is updated, otherwise it is the value to which alpha1 is fixed}
\item{alpha2_val}{starting value for alpha2 if alpha2 is updated, otherwise it is the value to which alpha2 is fixed}
\item{update_alpha1}{indicator determining if alpha1 should be udpated}
\item{update_alpha2}{indicator determining if alpha2 should be udpated}
\item{hierarchy}{If "YES", then mu_k ~ N(mu_0, sigma2_0), mu_0 ~ N(m0, s20), and sigma_0 ~ UN(0,A0)}
\item{m0}{mean of the prior distribution for mu_k if hierarchy = "No".  If hierarchy = "Yes", then it is the prior distribution for mu0 where my_k ~ N(mu0, sigma20).}
\item{s20}{variance of the prior distribution for mu_k}
\item{A}{upper bound of the uniform prior for sigma_k}
\item{A0}{needed for the hierarchical model only. It is the upper bound on the uniform of sigma0.}
\item{a0}{shape parameter of inverse gamma if mu_sigma_prior = 2 so that sigma2k ~ IG(a0, b0)}
\item{b0}{scale parameter of inverse gamma if mu_sigma_prior = 2 so that sigma2k ~ IG(a0, b0)}
\item{k0}{scale parameter of the NIG prior for (muk, sigma2k) when mu_sigma_prior = 3 and hierarchy = "No".  Not used otherwise}
\item{nu0}{degrees of freedom parameter of NIG prior for (muk, sigma2k) when mu_sigma_prior = 3 and hierarchy = "No".  Not used otherwise }
\item{alpha_grid}{grid provided for alpha when searching for lambda using pc prior.  If not supplied, then}
\item{alpha_density}{alpha density values}
\item{alpha0}{}
\item{alphaMax}{}
\item{ndens_y}{}
\item{niter}{Number of MCMC samples to collected.  Note that the number of MCMC iterates that are saved is (niter - nburn)/nthin.}
\item{nburn}{Number of MCMC samples to are discarded as burn-in.}
\item{nthin}{Number of the MCMC samples that are thinned after the burn-in phase of the sampler.}
}

\details{
This function carries out posterior sampling based on Neal's algorithm 8.
}

\value{
This function returns in a list the missing matrix, and MCMC iterates of all model parameters.  If psm=TRUE, then a vector containing indicator of which missing pattern each subject and the number of observations in each missing pattern is also provided.
}
\examples{


\dontrun{

}








}
